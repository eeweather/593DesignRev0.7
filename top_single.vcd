$date
	Mon Mar  6 20:10:49 2023
$end
$version
	QuestaSim Version 2019.2_1
$end
$timescale
	1ns
$end

$scope module top_single $end

$scope module vif $end
$var wire 1 ! done $end
$var wire 1 " op [2] $end
$var wire 1 # op [1] $end
$var wire 1 $ op [0] $end
$var reg 19 % instr [18:0] $end
$var reg 16 & result [15:0] $end
$var integer 8 ' A $end
$var integer 8 ( B $end
$var reg 1 ) clk $end
$var reg 1 * reset_n $end
$var reg 1 + reset_start $end
$var reg 1 , start $end

$scope task get_an_input $end
$upscope $end

$scope task get_an_output $end
$upscope $end

$scope task reset_alu $end
$upscope $end

$scope task sample_instruction $end
$upscope $end

$scope task send_instruction $end
$var reg 19 - i_instr [18:0] $end
$upscope $end
$upscope $end

$scope module DUT $end
$var wire 1 . clk $end
$var wire 19 % instr [18:0] $end
$var wire 1 / reset_n $end
$var reg 8 0 A [7:0] $end
$var reg 8 0 A_in [7:0] $end
$var reg 8 1 B [7:0] $end
$var reg 8 1 B_in [7:0] $end
$var reg 14 2 addr [13:0] $end
$var reg 14 3 addrout [13:0] $end
$var reg 1 4 alu_done $end
$var reg 16 5 alu_result [15:0] $end
$var reg 8 6 datafrommem [7:0] $end
$var reg 8 7 datatoinst [7:0] $end
$var reg 16 8 datatomem [15:0] $end
$var reg 1 9 done $end
$var reg 1 : error $end
$var reg 1 ; load $end
$var reg 1 < mem_done $end
$var reg 1 = mem_resp $end
$var reg 1 > preload $end
$var reg 1 ? read_req $end
$var reg 16 @ result [15:0] $end
$var reg 16 @ result_in [15:0] $end
$var reg 1 A start $end
$var reg 1 B store $end
$var reg 1 C write_req $end
$var reg 4 D op [3:0] $end

$scope module alu $end
$var wire 8 0 A [7:0] $end
$var wire 8 1 B [7:0] $end
$var wire 1 . clk $end
$var wire 1 / reset_n $end
$var reg 16 5 result [15:0] $end
$var reg 16 E result_multi [15:0] $end
$var reg 16 F result_single [15:0] $end
$var reg 1 G done $end
$var reg 1 H done_multi $end
$var reg 1 I done_single $end
$var reg 1 J error $end
$var reg 1 K start $end
$var reg 1 L start_multi $end
$var reg 1 M start_single $end
$var wire 4 D op [3:0] $end

$scope module alu_multi $end
$var wire 8 0 A [7:0] $end
$var wire 8 1 B [7:0] $end
$var wire 1 . clk $end
$var wire 1 / reset_n $end
$var wire 1 N start $end
$var reg 8 O a_int [7:0] $end
$var reg 8 P b_int [7:0] $end
$var reg 1 Q is_4cycle $end
$var reg 16 R mult1 [15:0] $end
$var reg 16 S mult2 [15:0] $end
$var reg 16 E result [15:0] $end
$var reg 1 H done $end
$var reg 1 T done1 $end
$var reg 1 U done2 $end
$var reg 1 V done3 $end
$var wire 4 D op [3:0] $end
$upscope $end

$scope module alu_single $end
$var wire 8 0 A [7:0] $end
$var wire 8 1 B [7:0] $end
$var wire 1 . clk $end
$var wire 1 / reset_n $end
$var wire 1 W start $end
$var reg 16 F result [15:0] $end
$var reg 1 I done $end
$var wire 4 D op [3:0] $end
$upscope $end
$upscope $end

$scope module instunit $end
$var wire 1 4 alu_done $end
$var wire 16 5 alu_result [15:0] $end
$var wire 1 . clk $end
$var wire 8 7 data [7:0] $end
$var wire 19 % instr [18:0] $end
$var wire 1 < mem_done $end
$var wire 1 / reset_n $end
$var reg 8 0 A [7:0] $end
$var reg 8 1 B [7:0] $end
$var reg 14 2 addr [13:0] $end
$var reg 14 X decode_addr [13:0] $end
$var reg 1 9 done $end
$var reg 1 ; load $end
$var reg 1 Y loadReg $end
$var reg 8 Z regA [7:0] $end
$var reg 8 [ regB [7:0] $end
$var reg 16 @ result [15:0] $end
$var reg 1 A start $end
$var reg 1 B store $end
$var integer 32 \ count $end
$var integer 32 ] fd $end
$var integer 32 ^ index $end
$var reg 4 _ op [3:0] $end
$var reg 4 ` opcode [3:0] $end

$scope begin send_instruction $end
$upscope $end
$upscope $end

$scope module memInt $end
$var wire 14 2 addr [13:0] $end
$var wire 1 . clk $end
$var wire 16 a datafrommem [15:0] $end
$var wire 1 ; load $end
$var wire 1 = mem_resp $end
$var wire 1 / reset_n $end
$var wire 16 @ result [15:0] $end
$var wire 1 B store $end
$var reg 14 3 addrout [13:0] $end
$var reg 4 b counter [3:0] $end
$var reg 8 7 datatoinst [7:0] $end
$var reg 16 8 datatomem [15:0] $end
$var reg 1 < mem_done $end
$var reg 1 ? read_req $end
$var reg 1 C write_req $end
$upscope $end

$scope module sram $end
$var wire 14 3 addr [13:0] $end
$var wire 1 . clk $end
$var wire 16 8 datafrommif [15:0] $end
$var wire 1 > preload $end
$var wire 1 ? re $end
$var wire 1 / reset_n $end
$var wire 1 C we $end
$var parameter 32 c ADDR_WIDTH $end
$var parameter 32 d DATA_WIDTH $end
$var reg 8 6 datatomif [7:0] $end
$var reg 1 = mem_resp $end
